<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Enhanced Sensor Camera with Full Controls</title>
<style>
  body {
    font-family: monospace;
    background: #111;
    color: #eee;
    padding: 1em;
    max-width: 800px;
    margin: auto;
  }
  .video-container {
    position: relative;
    margin-bottom: 1em;
  }
  video {
    width: 100%;
    border-radius: 8px;
    background: black;
    cursor: crosshair;
  }
  .focus-indicator {
    position: absolute;
    width: 60px;
    height: 60px;
    border: 2px solid #4CAF50;
    border-radius: 50%;
    pointer-events: none;
    display: none;
    animation: focusPulse 0.5s ease-out;
  }
  .wb-indicator {
    position: absolute;
    width: 40px;
    height: 40px;
    border: 2px solid #FFA500;
    border-radius: 4px;
    pointer-events: none;
    display: none;
    animation: wbPulse 0.5s ease-out;
  }
  @keyframes focusPulse {
    0% { transform: scale(1.5); opacity: 0; }
    100% { transform: scale(1); opacity: 1; }
  }
  @keyframes wbPulse {
    0% { transform: scale(1.5); opacity: 0; }
    100% { transform: scale(1); opacity: 1; }
  }
  pre {
    background: #222;
    padding: 1em;
    border-radius: 8px;
    max-height: 300px;
    overflow-y: auto;
  }
  button, select, input {
    font-size: 1rem;
    padding: 0.5em;
    margin: 0.3em 0;
    cursor: pointer;
    background: #333;
    color: #eee;
    border: 1px solid #555;
    border-radius: 4px;
  }
  button.active {
    background: #4CAF50;
    color: white;
  }
  .controls-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1em;
    margin: 1em 0;
  }
  .control-group {
    background: #222;
    padding: 1em;
    border-radius: 8px;
  }
  .control-group h3 {
    margin-top: 0;
    color: #4CAF50;
  }
  .slider-container {
    margin: 0.5em 0;
  }
  .slider-container label {
    display: block;
    margin-bottom: 0.3em;
  }
  .slider-container input[type="range"] {
    width: 100%;
    margin: 0;
  }
  .value-display {
    color: #FFA500;
    font-weight: bold;
  }
  .button-group {
    display: flex;
    gap: 0.5em;
    flex-wrap: wrap;
  }
  .interval-controls {
    background: #2a2a2a;
    padding: 1em;
    border-radius: 8px;
    margin: 1em 0;
  }
  .interval-controls h3 {
    margin-top: 0;
    color: #FF6B6B;
  }
  .interval-input {
    width: 80px;
    text-align: center;
  }
  .capture-counter {
    color: #51cf66;
    font-weight: bold;
    margin-left: 1em;
  }
  #cameraInfo {
    background: #1a1a1a;
    padding: 1em;
    border-radius: 8px;
    margin: 1em 0;
    font-size: 0.9em;
  }
  .error {
    color: #ff6b6b;
    background: #2d1515;
    padding: 1em;
    border-radius: 8px;
    margin: 1em 0;
  }
  .status {
    color: #51cf66;
    background: #1a2e1a;
    padding: 0.5em;
    border-radius: 4px;
    margin: 0.5em 0;
  }
  .touch-instructions {
    background: #1a1a2e;
    color: #87ceeb;
    padding: 0.8em;
    border-radius: 8px;
    margin: 1em 0;
    font-size: 0.9em;
  }
</style>
</head>
<body>

<h1>📸 Enhanced Sensor Camera</h1>

<div id="permissionStatus" class="status">Checking permissions...</div>

<div class="button-group">
  <button onclick="requestPermissions()">🔐 Request Permissions</button>
  <select id="cameraSelect"><option>Loading cameras...</option></select>
  <select id="resolutionSelect">
    <option value="640x480">640x480</option>
    <option value="1280x720">1280x720 (HD)</option>
    <option value="1920x1080">1920x1080 (FHD)</option>
    <option value="2560x1440">2560x1440 (QHD)</option>
    <option value="3840x2160">3840x2160 (4K)</option>
  </select>
  <button onclick="startCamera()">🎥 Start Camera</button>
  <button onclick="capturePhoto()">📷 Capture Photo</button>
</div>

<div class="touch-instructions">
  🎯 <strong>Touch Controls:</strong> Single tap to focus • Double tap for white balance • Touch and hold for manual focus lock
</div>

<div class="video-container">
  <video id="video" autoplay playsinline muted></video>
  <div id="focusIndicator" class="focus-indicator"></div>
  <div id="wbIndicator" class="wb-indicator"></div>
</div>

<div class="interval-controls">
  <h3>⏱️ Interval Capture</h3>
  <div class="button-group">
    <button id="intervalToggle" onclick="toggleIntervalCapture()">▶️ Start Interval</button>
    <label>Interval (seconds): <input id="intervalInput" type="number" class="interval-input" min="0.1" step="0.1" value="0.1"></label>
    <span class="capture-counter">Photos: <span id="captureCount">0</span></span>
  </div>
  <div style="margin-top: 0.5em;">
    <button onclick="resetCounter()">🔄 Reset Counter</button>
    <button onclick="downloadCaptureLog()">📋 Download Log</button>
  </div>
</div>

<div class="controls-grid">
  <div class="control-group">
    <h3>🔍 Focus & Zoom</h3>
    <div class="slider-container">
      <label>Focus Distance: <span id="focusDistanceValue" class="value-display">Auto</span></label>
      <input type="range" id="focusDistanceSlider" min="0" max="100" value="0">
    </div>
    <div class="slider-container">
      <label>Zoom: <span id="zoomValue" class="value-display">1x</span></label>
      <input type="range" id="zoomSlider" min="1" max="10" step="0.1" value="1">
    </div>
    <div class="button-group">
      <button onclick="setFocusMode('manual')">Manual Focus</button>
      <button onclick="setFocusMode('continuous')">Auto Focus</button>
    </div>
  </div>

  <div class="control-group">
    <h3>💡 Exposure</h3>
    <div class="slider-container">
      <label>Exposure Time: <span id="exposureTimeValue" class="value-display">Auto</span></label>
      <input type="range" id="exposureTimeSlider" min="1" max="1000" value="1">
    </div>
    <div class="slider-container">
      <label>ISO: <span id="isoValue" class="value-display">Auto</span></label>
      <input type="range" id="isoSlider" min="50" max="3200" step="50" value="100">
    </div>
    <div class="slider-container">
      <label>Exposure Compensation: <span id="exposureCompValue" class="value-display">0</span></label>
      <input type="range" id="exposureCompSlider" min="-3" max="3" step="0.1" value="0">
    </div>
    <div class="button-group">
      <button onclick="setExposureMode('manual')">Manual</button>
      <button onclick="setExposureMode('continuous')">Auto</button>
    </div>
  </div>

  <div class="control-group">
    <h3>🌈 Color & White Balance</h3>
    <div class="slider-container">
      <label>White Balance: <span id="whiteBalanceValue" class="value-display">Auto</span></label>
      <input type="range" id="whiteBalanceSlider" min="2000" max="8000" step="100" value="5500">
    </div>
    <div class="slider-container">
      <label>Saturation: <span id="saturationValue" class="value-display">50</span></label>
      <input type="range" id="saturationSlider" min="0" max="100" value="50">
    </div>
    <div class="slider-container">
      <label>Contrast: <span id="contrastValue" class="value-display">50</span></label>
      <input type="range" id="contrastSlider" min="0" max="100" value="50">
    </div>
    <div class="slider-container">
      <label>Brightness: <span id="brightnessValue" class="value-display">50</span></label>
      <input type="range" id="brightnessSlider" min="0" max="100" value="50">
    </div>
    <div class="button-group">
      <button onclick="setWhiteBalanceMode('manual')">Manual WB</button>
      <button onclick="setWhiteBalanceMode('continuous')">Auto WB</button>
    </div>
  </div>

  <div class="control-group">
    <h3>⚙️ Advanced Settings</h3>
    <div class="slider-container">
      <label>Sharpness: <span id="sharpnessValue" class="value-display">50</span></label>
      <input type="range" id="sharpnessSlider" min="0" max="100" value="50">
    </div>
    <div class="button-group">
      <button onclick="toggleTorch()">🔦 Toggle Torch</button>
      <button onclick="resetAllSettings()">🔄 Reset All</button>
      <button onclick="switchCamera()">🔄 Switch Camera</button>
    </div>
  </div>
</div>

<div id="cameraInfo">
  <h3>📊 Camera Capabilities</h3>
  <pre id="capabilitiesDisplay">No camera active</pre>
</div>

<div id="errorDisplay"></div>

<h2>📡 Sensor Data</h2>
<pre id="sensorData">Waiting for sensor data...</pre>

<canvas id="canvas" style="display:none;"></canvas>

<script>
(async () => {
  const videoEl = document.getElementById("video");
  const sensorDataEl = document.getElementById("sensorData");
  const canvas = document.getElementById("canvas");
  const resolutionSelect = document.getElementById("resolutionSelect");
  const cameraSelect = document.getElementById("cameraSelect");
  const capabilitiesDisplay = document.getElementById("capabilitiesDisplay");
  const permissionStatus = document.getElementById("permissionStatus");
  const errorDisplay = document.getElementById("errorDisplay");
  const focusIndicator = document.getElementById("focusIndicator");
  const wbIndicator = document.getElementById("wbIndicator");
  const intervalToggle = document.getElementById("intervalToggle");
  const intervalInput = document.getElementById("intervalInput");
  const captureCountEl = document.getElementById("captureCount");
  
  let currentStream = null;
  let currentTrack = null;
  let capabilities = {};
  let torchEnabled = false;
  let availableCameras = [];
  let currentCameraIndex = 0;
  let permissionsGranted = false;
  let intervalCapture = null;
  let captureCount = 0;
  let captureLog = [];
  let lastTouchTime = 0;
  let touchTimeout = null;
  
  const data = {
    deviceOrientation: {},
    deviceMotion: {},
    geolocation: {},
    ambientLight: null,
    magnetometer: null,
    gyroscope: null,
    accelerometer: null
  };

  const fmt = v => (v == null || isNaN(v)) ? "NA" : parseFloat(v).toFixed(8);

  function showError(message) {
    errorDisplay.innerHTML = `<div class="error">❌ ${message}</div>`;
    console.error(message);
  }

  function clearError() {
    errorDisplay.innerHTML = '';
  }

  function updateStatus(message) {
    permissionStatus.textContent = message;
  }

  function updateDisplay() {
    sensorDataEl.textContent = JSON.stringify(data, null, 2);
  }

  function updateSliderValue(sliderId, valueId, value, suffix = '') {
    const valueEl = document.getElementById(valueId);
    if (valueEl) {
      valueEl.textContent = value + suffix;
    }
  }

  // Touch controls for video element
  function setupTouchControls() {
    videoEl.addEventListener('touchstart', handleTouch);
    videoEl.addEventListener('click', handleTouch);
    
    // Prevent default touch behaviors
    videoEl.addEventListener('touchmove', e => e.preventDefault());
    videoEl.addEventListener('touchend', e => e.preventDefault());
  }

  function handleTouch(e) {
    e.preventDefault();
    
    const rect = videoEl.getBoundingClientRect();
    const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
    const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
    
    const now = Date.now();
    const isDoubleTouch = (now - lastTouchTime) < 300;
    
    if (e.type === 'touchstart' && !isDoubleTouch) {
      // Set up potential long press
      touchTimeout = setTimeout(() => {
        handleLongPress(x, y);
      }, 500);
    }
    
    if (e.type === 'touchend' || e.type === 'click') {
      if (touchTimeout) {
        clearTimeout(touchTimeout);
        touchTimeout = null;
      }
      
      if (isDoubleTouch) {
        handleDoubleTouch(x, y);
      } else {
        setTimeout(() => {
          if (Date.now() - now > 250) return; // Prevent single tap if double tap occurred
          handleSingleTouch(x, y);
        }, 250);
      }
    }
    
    lastTouchTime = now;
  }

  function handleSingleTouch(x, y) {
    // Focus at touch point
    showFocusIndicator(x, y);
    setFocusPoint(x, y);
  }

  function handleDoubleTouch(x, y) {
    // White balance at touch point
    showWBIndicator(x, y);
    setWhiteBalancePoint(x, y);
  }

  function handleLongPress(x, y) {
    // Manual focus lock
    showFocusIndicator(x, y);
    setFocusPoint(x, y);
    setFocusMode('manual');
  }

  function showFocusIndicator(x, y) {
    focusIndicator.style.left = (x - 30) + 'px';
    focusIndicator.style.top = (y - 30) + 'px';
    focusIndicator.style.display = 'block';
    
    setTimeout(() => {
      focusIndicator.style.display = 'none';
    }, 1000);
  }

  function showWBIndicator(x, y) {
    wbIndicator.style.left = (x - 20) + 'px';
    wbIndicator.style.top = (y - 20) + 'px';
    wbIndicator.style.display = 'block';
    
    setTimeout(() => {
      wbIndicator.style.display = 'none';
    }, 1000);
  }

  function setFocusPoint(x, y) {
    if (!currentTrack || !capabilities.focusDistance) return;
    
    const rect = videoEl.getBoundingClientRect();
    const normalizedX = x / rect.width;
    const normalizedY = y / rect.height;
    
    // Simple distance-based focus (closer to center = closer focus)
    const centerDistance = Math.sqrt(
      Math.pow(normalizedX - 0.5, 2) + Math.pow(normalizedY - 0.5, 2)
    );
    
    const focusValue = Math.max(0.1, 1 - centerDistance);
    const focusDistance = capabilities.focusDistance.min + 
      (capabilities.focusDistance.max - capabilities.focusDistance.min) * focusValue;
    
    applyConstraint({ focusMode: 'manual', focusDistance: focusDistance });
    
    // Update UI slider
    const focusSlider = document.getElementById('focusDistanceSlider');
    focusSlider.value = focusValue * 100;
    updateSliderValue('focusDistanceSlider', 'focusDistanceValue', Math.round(focusValue * 100) + '%');
  }

  function setWhiteBalancePoint(x, y) {
    if (!currentTrack || !capabilities.colorTemperature) return;
    
    const rect = videoEl.getBoundingClientRect();
    const normalizedX = x / rect.width;
    
    // Map X position to color temperature (left = warm, right = cool)
    const tempRange = capabilities.colorTemperature.max - capabilities.colorTemperature.min;
    const colorTemp = capabilities.colorTemperature.min + (tempRange * normalizedX);
    
    applyConstraint({ whiteBalanceMode: 'manual', colorTemperature: colorTemp });
    
    // Update UI slider
    const wbSlider = document.getElementById('whiteBalanceSlider');
    wbSlider.value = colorTemp;
    updateSliderValue('whiteBalanceSlider', 'whiteBalanceValue', Math.round(colorTemp) + 'K');
  }

  // Interval capture functionality
  window.toggleIntervalCapture = function() {
    if (intervalCapture) {
      stopIntervalCapture();
    } else {
      startIntervalCapture();
    }
  };

  function startIntervalCapture() {
    if (!currentStream) {
      showError("No camera stream active");
      return;
    }

    const interval = parseFloat(intervalInput.value) * 1000; // Convert to milliseconds
    if (interval < 100) {
      showError("Minimum interval is 0.1 seconds");
      return;
    }

    intervalCapture = setInterval(() => {
      capturePhoto(true); // true indicates interval capture
    }, interval);

    intervalToggle.textContent = "⏹️ Stop Interval";
    intervalToggle.classList.add('active');
    intervalInput.disabled = true;
    
    updateStatus(`📸 Interval capture started (${intervalInput.value}s)`);
  }

  function stopIntervalCapture() {
    if (intervalCapture) {
      clearInterval(intervalCapture);
      intervalCapture = null;
    }

    intervalToggle.textContent = "▶️ Start Interval";
    intervalToggle.classList.remove('active');
    intervalInput.disabled = false;
    
    updateStatus("⏹️ Interval capture stopped");
  }

  window.resetCounter = function() {
    captureCount = 0;
    captureCountEl.textContent = captureCount;
    captureLog = [];
  };

  window.downloadCaptureLog = function() {
    if (captureLog.length === 0) {
      showError("No captures to log");
      return;
    }

    const logContent = captureLog.map(entry => JSON.stringify(entry)).join('\n');
    const blob = new Blob([logContent], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `capture_log_${Date.now()}.txt`;
    a.click();
    URL.revokeObjectURL(url);
  };

  window.requestPermissions = async () => {
    try {
      updateStatus("Requesting camera permissions...");
      
      // First, try to get basic camera access
      const stream = await navigator.mediaDevices.getUserMedia({ 
        video: { facingMode: 'environment' }
      });
      
      // Stop the stream immediately after getting permission
      stream.getTracks().forEach(track => track.stop());
      
      permissionsGranted = true;
      updateStatus("✅ Permissions granted! Enumerating cameras...");
      
      await enumerateCameras();
      
    } catch (error) {
      showError(`Permission denied: ${error.message}. Please allow camera access and try again.`);
      updateStatus("❌ Permission denied");
    }
  };

  async function enumerateCameras() {
    try {
      const devices = await navigator.mediaDevices.enumerateDevices();
      const videoDevices = devices.filter(d => d.kind === 'videoinput');
      
      if (videoDevices.length === 0) {
        throw new Error("No cameras found on this device");
      }
      
      availableCameras = videoDevices;
      cameraSelect.innerHTML = '';
      
      videoDevices.forEach((device, index) => {
        const option = document.createElement('option');
        option.value = device.deviceId;
        
        // Better camera labeling for mobile devices
        let label = device.label;
        if (!label || label === '') {
          if (index === 0) label = "Camera 1 (Main)";
          else if (index === 1) label = "Camera 2 (Front/Secondary)";
          else label = `Camera ${index + 1}`;
        }
        
        // Try to identify front/back cameras
        if (label.toLowerCase().includes('front') || label.toLowerCase().includes('user')) {
          label += " 🤳";
        } else if (label.toLowerCase().includes('back') || label.toLowerCase().includes('environment')) {
          label += " 📷";
        }
        
        option.text = label;
        cameraSelect.appendChild(option);
      });
      
      updateStatus(`✅ Found ${videoDevices.length} camera(s)`);
      clearError();
      
    } catch (error) {
      showError(`Failed to enumerate cameras: ${error.message}`);
    }
  }

  function setupSliderListeners() {
    // Focus Distance
    const focusSlider = document.getElementById('focusDistanceSlider');
    focusSlider.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      updateSliderValue('focusDistanceSlider', 'focusDistanceValue', value === 0 ? 'Auto' : value + '%');
      if (currentTrack && capabilities.focusDistance) {
        const distance = capabilities.focusDistance.min + (capabilities.focusDistance.max - capabilities.focusDistance.min) * value / 100;
        applyConstraint({ focusDistance: distance });
      }
    });

    // Zoom
    const zoomSlider = document.getElementById('zoomSlider');
    zoomSlider.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      updateSliderValue('zoomSlider', 'zoomValue', value + 'x');
      if (currentTrack && capabilities.zoom) {
        applyConstraint({ zoom: value });
      }
    });

    // Exposure Time
    const exposureSlider = document.getElementById('exposureTimeSlider');
    exposureSlider.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      updateSliderValue('exposureTimeSlider', 'exposureTimeValue', value === 1 ? 'Auto' : '1/' + value + 's');
      if (currentTrack && capabilities.exposureTime) {
        const exposureTime = 1 / value;
        applyConstraint({ exposureTime: exposureTime });
      }
    });

    // ISO
    const isoSlider = document.getElementById('isoSlider');
    isoSlider.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      updateSliderValue('isoSlider', 'isoValue', value);
      if (currentTrack && capabilities.iso) {
        applyConstraint({ iso: value });
      }
    });

    // Exposure Compensation
    const exposureCompSlider = document.getElementById('exposureCompSlider');
    exposureCompSlider.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      updateSliderValue('exposureCompSlider', 'exposureCompValue', value);
      if (currentTrack && capabilities.exposureCompensation) {
        applyConstraint({ exposureCompensation: value });
      }
    });

    // White Balance
    const wbSlider = document.getElementById('whiteBalanceSlider');
    wbSlider.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      updateSliderValue('whiteBalanceSlider', 'whiteBalanceValue', value + 'K');
      if (currentTrack && capabilities.colorTemperature) {
        applyConstraint({ whiteBalanceMode: 'manual', colorTemperature: value });
      }
    });

    // Image adjustments
    ['saturation', 'contrast', 'brightness', 'sharpness'].forEach(setting => {
      const slider = document.getElementById(setting + 'Slider');
      slider.addEventListener('input', (e) => {
        const value = parseFloat(e.target.value);
        updateSliderValue(setting + 'Slider', setting + 'Value', value);
        if (currentTrack && capabilities[setting]) {
          const range = capabilities[setting];
          const actualValue = range.min + (range.max - range.min) * value / 100;
          applyConstraint({ [setting]: actualValue });
        }
      });
    });
  }

  async function applyConstraint(constraint) {
    if (!currentTrack) return;
    try {
      await currentTrack.applyConstraints({ advanced: [constraint] });
    } catch (e) {
      console.warn('Failed to apply constraint:', constraint, e.message);
    }
  }

  function displayCapabilities() {
    if (!capabilities || Object.keys(capabilities).length === 0) {
      capabilitiesDisplay.textContent = "No camera capabilities available";
      return;
    }

    const relevant = {};
    ['zoom', 'focusDistance', 'focusMode', 'exposureMode', 'exposureTime', 'exposureCompensation', 
     'iso', 'whiteBalanceMode', 'colorTemperature', 'brightness', 'contrast', 'saturation', 
     'sharpness', 'torch'].forEach(key => {
      if (capabilities[key]) relevant[key] = capabilities[key];
    });

    capabilitiesDisplay.textContent = JSON.stringify(relevant, null, 2);
  }

  function setupSliderRanges() {
    // Update slider ranges based on capabilities
    if (capabilities.zoom) {
      const zoomSlider = document.getElementById('zoomSlider');
      zoomSlider.min = capabilities.zoom.min;
      zoomSlider.max = capabilities.zoom.max;
      zoomSlider.step = (capabilities.zoom.max - capabilities.zoom.min) / 100;
    }

    if (capabilities.focusDistance) {
      const focusSlider = document.getElementById('focusDistanceSlider');
      focusSlider.min = 0;
      focusSlider.max = 100;
    }

    if (capabilities.exposureTime) {
      const expSlider = document.getElementById('exposureTimeSlider');
      expSlider.min = Math.ceil(1 / capabilities.exposureTime.max);
      expSlider.max = Math.ceil(1 / capabilities.exposureTime.min);
    }

    if (capabilities.colorTemperature) {
      const wbSlider = document.getElementById('whiteBalanceSlider');
      wbSlider.min = capabilities.colorTemperature.min;
      wbSlider.max = capabilities.colorTemperature.max;
    }
  }

  window.startCamera = async () => {
    if (!permissionsGranted) {
      showError("Please request permissions first");
      return;
    }

    if (currentStream) {
      currentStream.getTracks().forEach(track => track.stop());
    }

    const [width, height] = resolutionSelect.value.split('x').map(Number);
    const deviceId = cameraSelect.value;
    
    if (!deviceId) {
      showError("No camera selected");
      return;
    }

    // Try multiple constraint configurations for better compatibility
    const constraintConfigs = [
      // Exact constraints
      {
        video: {
          deviceId: { exact: deviceId },
          width: { exact: width },
          height: { exact: height }
        }
      },
      // Ideal constraints (fallback)
      {
        video: {
          deviceId: { exact: deviceId },
          width: { ideal: width },
          height: { ideal: height }
        }
      },
      // Basic constraints (last resort)
      {
        video: {
          deviceId: { exact: deviceId }
        }
      }
    ];

    for (const constraints of constraintConfigs) {
      try {
        updateStatus("Starting camera...");
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        
        videoEl.srcObject = stream;
        currentStream = stream;
        currentTrack = stream.
